use std::net::IpAddr;
use std::time::Duration;
use tokio::sync::mpsc;
use tokio::time::timeout;
use tokio::net::TcpStream;
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use log::{debug, info, error};
use crate::common::utils;
use crate::scanner::ServiceInfo;

#[derive(Debug, Clone)]
pub struct MS17010Result {
    pub ip: IpAddr,
    pub port: u16,
    pub is_vulnerable: bool,
    pub details: String,
}

pub async fn scan(
    services: &[ServiceInfo],
    timeout_secs: u64,
    threads: usize,
) -> Result<Vec<MS17010Result>, Box<dyn std::error::Error>> {
    // 过滤出可能运行SMB的服务
    let smb_services: Vec<&ServiceInfo> = services
        .iter()
        .filter(|s| s.service.contains("smb") || s.port == 445)
        .collect();
    
    if smb_services.is_empty() {
        return Ok(Vec::new());
    }
    
    info!("Starting MS17-010 vulnerability scan for {} potential SMB services...", smb_services.len());
    
    let pb = utils::create_progress_bar(smb_services.len() as u64, "Scanning for MS17-010");
    let (tx, mut rx) = mpsc::channel(threads);
    let timeout_duration = Duration::from_secs(timeout_secs);
    
    // 分块处理
    let chunk_size = (smb_services.len() + threads - 1) / threads;
    let chunks: Vec<Vec<&ServiceInfo>> = smb_services
        .chunks(chunk_size)
        .map(|chunk| chunk.to_vec())
        .collect();
    
    for chunk in chunks {
        let tx = tx.clone();
        let timeout_duration = timeout_duration;
        let pb = pb.clone();
        
        tokio::spawn(async move {
            for service in chunk {
                if let Some(result) = check_ms17010(
                    service.ip,
                    service.port,
                    timeout_duration
                ).await {
                    let _ = tx.send(result).await;
                }
                pb.inc(1);
            }
        });
    }
    
    // 丢弃原始发送者
    drop(tx);
    
    // 收集结果
    let mut results = Vec::new();
    while let Some(result) = rx.recv().await {
        results.push(result);
    }
    
    pb.finish_with_message(format!("Found {} MS17-010 vulnerable hosts", results.len()));
    
    Ok(results)
}

async fn check_ms17010(
    ip: IpAddr,
    port: u16,
    timeout_duration: Duration,
) -> Option<MS17010Result> {
    let addr = format!("{}:{}", ip, port);
    let connect_result = timeout(timeout_duration, TcpStream::connect(&addr)).await;
    
    match connect_result {
        Ok(Ok(mut stream)) => {
            // 发送SMB协商协议请求
            let negotiate_packet = create_smb_negotiate_packet();
            
            if let Err(e) = stream.write_all(&negotiate_packet).await {
                error!("Failed to send SMB negotiate packet to {}:{}: {}", ip, port, e);
                return None;
            }
            
            // 读取响应
            let mut response = vec![0; 1024];
            let read_result = timeout(
                timeout_duration,
                stream.read(&mut response)
            ).await;
            
            match read_result {
                Ok(Ok(n)) if n > 0 => {
                    // 发送SMB会话设置请求
                    let session_setup_packet = create_smb_session_setup_packet();
                    
                    if let Err(e) = stream.write_all(&session_setup_packet).await {
                        error!("Failed to send SMB session setup packet to {}:{}: {}", ip, port, e);
                        return None;
                    }
                    
                    // 读取响应
                    let mut response = vec![0; 1024];
                    let read_result = timeout(
                        timeout_duration,
                        stream.read(&mut response)
                    ).await;
                    
                    match read_result {
                        Ok(Ok(n)) if n > 0 => {
                            // 检查响应是否表明目标易受MS17-010影响
                            let is_vulnerable = is_ms17010_vulnerable(&response[..n]);
                            
                            if is_vulnerable {
                                debug!("Host {}:{} is vulnerable to MS17-010", ip, port);
                                
                                return Some(MS17010Result {
                                    ip,
                                    port,
                                    is_vulnerable: true,
                                    details: "Potentially vulnerable to MS17-010 (EternalBlue)".to_string(),
                                });
                            }
                        },
                        _ => {},
                    }
                },
                _ => {},
            }
        },
        _ => {},
    }
    
    None
}

fn create_smb_negotiate_packet() -> Vec<u8> {
    // SMB Negotiate Protocol Request
    vec![
        0x00, 0x00, 0x00, 0x85, 0xFF, 0x53, 0x4D, 0x42, 
        0x72, 0x00, 0x00, 0x00, 0x00, 0x18, 0x53, 0xC8, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x00, 0x02, 
        0x50, 0x43, 0x20, 0x4E, 0x45, 0x54, 0x57, 0x4F, 
        0x52, 0x4B, 0x20, 0x50, 0x52, 0x4F, 0x47, 0x52, 
        0x41, 0x4D, 0x20, 0x31, 0x2E, 0x30, 0x00, 0x02, 
        0x4C, 0x41, 0x4E, 0x4D, 0x41, 0x4E, 0x31, 0x2E, 
        0x30, 0x00, 0x02, 0x57, 0x69, 0x6E, 0x64, 0x6F, 
        0x77, 0x73, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x57, 
        0x6F, 0x72, 0x6B, 0x67, 0x72, 0x6F, 0x75, 0x70, 
        0x73, 0x20, 0x33, 0x2E, 0x31, 0x61, 0x00, 0x02, 
        0x4C, 0x4D, 0x31, 0x2E, 0x32, 0x58, 0x30, 0x30, 
        0x32, 0x00, 0x02, 0x4C, 0x41, 0x4E, 0x4D, 0x41, 
        0x4E, 0x32, 0x2E, 0x31, 0x00, 0x02, 0x4E, 0x54, 
        0x20, 0x4C, 0x4D, 0x20, 0x30, 0x2E, 0x31, 0x32, 
        0x00
    ]
}

fn create_smb_session_setup_packet() -> Vec<u8> {
    // SMB Session Setup AndX Request
    vec![
        0x00, 0x00, 0x00, 0x88, 0xFF, 0x53, 0x4D, 0x42, 
        0x73, 0x00, 0x00, 0x00, 0x00, 0x18, 0x07, 0xC8, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 
        0x00, 0x00, 0x00, 0x00, 0x0D, 0xFF, 0x00, 0x00, 
        0x00, 0xFF, 0xFF, 0x02, 0x00, 0x01, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00
    ]
}

fn is_ms17010_vulnerable(response: &[u8]) -> bool {
    // 检查响应是否有足够的字节
    if response.len() < 32 {
        return false;
    }
    
    // 检查SMB签名
    if &response[4..8] != b"\xffSMB" {
        return false;
    }
    
    // 基于响应中的特定签名检测MS17-010漏洞
    // 第32个字节（0索引）是MS17-010检测的关键字段
    if response[9] == 0x73 {
        // 查找STATUS_INSUFF_SERVER_RESOURCES
        if response.len() > 45 && (response[34] == 0x11 || response[34] == 0x0b) {
            return true;
        }
    }
    
    false
}

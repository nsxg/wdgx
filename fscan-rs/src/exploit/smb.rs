// src/exploit/smb.rs

use std::net::IpAddr;
use std::time::Duration;
use tokio::sync::mpsc;
use tokio::time::timeout;
use tokio::net::TcpStream;
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use log::{debug, info, error};
use crate::common::utils;
use crate::scanner::ServiceInfo;

#[derive(Debug, Clone)]
pub struct SmbVulnResult {
    pub ip: IpAddr,
    pub port: u16,
    pub is_vulnerable: bool,
    pub vulnerability: String,
    pub details: String,
}

pub async fn scan(
    services: &[ServiceInfo],
    timeout_secs: u64,
    threads: usize,
) -> Result<Vec<SmbVulnResult>, Box<dyn std::error::Error>> {
    // 过滤出SMB服务
    let smb_services: Vec<&ServiceInfo> = services
        .iter()
        .filter(|s| s.service.contains("smb") || s.port == 445 || s.port == 139)
        .collect();
    
    if smb_services.is_empty() {
        return Ok(Vec::new());
    }
    
    info!("Starting SMB vulnerability scan for {} SMB services...", smb_services.len());
    
    let pb = utils::create_progress_bar(smb_services.len() as u64, "Scanning SMB services");
    let (tx, mut rx) = mpsc::channel(threads);
    let timeout_duration = Duration::from_secs(timeout_secs);
    
    // 分块处理
    let chunk_size = (smb_services.len() + threads - 1) / threads;
    let chunks: Vec<Vec<&ServiceInfo>> = smb_services
        .chunks(chunk_size)
        .map(|chunk| chunk.to_vec())
        .collect();
    
    for chunk in chunks {
        let tx = tx.clone();
        let timeout_duration = timeout_duration;
        let pb = pb.clone();
        
        tokio::spawn(async move {
            for service in chunk {
                // 检查SMB Ghost漏洞 (CVE-2020-0796)
                if let Some(result) = check_smb_ghost(
                    service.ip,
                    service.port,
                    timeout_duration
                ).await {
                    let _ = tx.send(result).await;
                }
                
                // 检查SMB v1漏洞
                if let Some(result) = check_smb_v1(
                    service.ip,
                    service.port,
                    timeout_duration
                ).await {
                    let _ = tx.send(result).await;
                }
                
                pb.inc(1);
            }
        });
    }
    
    // 丢弃原始发送者
    drop(tx);
    
    // 收集结果
    let mut results = Vec::new();
    while let Some(result) = rx.recv().await {
        results.push(result);
    }
    
    pb.finish_with_message(format!("Found {} vulnerable SMB services", results.len()));
    
    Ok(results)
}

async fn check_smb_ghost(
    ip: IpAddr,
    port: u16,
    timeout_duration: Duration,
) -> Option<SmbVulnResult> {
    let addr = format!("{}:{}", ip, port);
    let connect_result = timeout(timeout_duration, TcpStream::connect(&addr)).await;
    
    match connect_result {
        Ok(Ok(mut stream)) => {
            // SMB协议协商请求
            let negotiate_protocol_request = create_smb_negotiate_packet();
            
            if let Err(e) = stream.write_all(&negotiate_protocol_request).await {
                error!("Failed to send SMB negotiate packet to {}:{}: {}", ip, port, e);
                return None;
            }
            
            // 读取响应
            let mut response = vec![0; 1024];
            let read_result = timeout(
                timeout_duration,
                stream.read(&mut response)
            ).await;
            
            match read_result {
                Ok(Ok(n)) if n > 0 => {
                    // 检查是否支持SMB 3.1.1 - SMBGhost漏洞需要这个版本
                    if is_vulnerable_to_smbghost(&response[..n]) {
                        debug!("Host {}:{} is potentially vulnerable to SMBGhost (CVE-2020-0796)", ip, port);
                        
                        return Some(SmbVulnResult {
                            ip,
                            port,
                            is_vulnerable: true,
                            vulnerability: "CVE-2020-0796".to_string(),
                            details: "SMBGhost vulnerability in SMB v3.1.1 (Windows 10 1903/1909)".to_string(),
                        });
                    }
                },
                _ => {},
            }
        },
        _ => {},
    }
    
    None
}

async fn check_smb_v1(
    ip: IpAddr,
    port: u16,
    timeout_duration: Duration,
) -> Option<SmbVulnResult> {
    let addr = format!("{}:{}", ip, port);
    let connect_result = timeout(timeout_duration, TcpStream::connect(&addr)).await;
    
    match connect_result {
        Ok(Ok(mut stream)) => {
            // SMBv1专用协议协商请求
            let negotiate_protocol_request = create_smbv1_negotiate_packet();
            
            if let Err(e) = stream.write_all(&negotiate_protocol_request).await {
                error!("Failed to send SMBv1 negotiate packet to {}:{}: {}", ip, port, e);
                return None;
            }
            
            // 读取响应
            let mut response = vec![0; 1024];
            let read_result = timeout(
                timeout_duration,
                stream.read(&mut response)
            ).await;
            
            match read_result {
                Ok(Ok(n)) if n > 0 => {
                    // 检查是否支持SMBv1
                    if is_smbv1_supported(&response[..n]) {
                        debug!("Host {}:{} supports vulnerable SMBv1 protocol", ip, port);
                        
                        return Some(SmbVulnResult {
                            ip,
                            port,
                            is_vulnerable: true,
                            vulnerability: "SMBv1".to_string(),
                            details: "System supports deprecated SMBv1 protocol (WannaCry, EternalBlue, etc.)".to_string(),
                        });
                    }
                },
                _ => {},
            }
        },
        _ => {},
    }
    
    None
}

// 创建SMB协议协商数据包
fn create_smb_negotiate_packet() -> Vec<u8> {
    // SMB协商协议请求，请求SMB 3.1.1以检测SMBGhost
    vec![
        0x00, 0x00, 0x00, 0x9b, 0xfe, 0x53, 0x4d, 0x42, 
        0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x24, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02, 0x10, 
        0x02, 0x00, 0x03, 0x02, 0x03, 0x11, 0x03, 0x00, 
        0x00, 0x00, 0x01, 0x00, 0x26, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x01, 0x00, 0x20, 0x00, 0x01, 0x00
    ]
}

// 创建SMBv1专用协议协商数据包
fn create_smbv1_negotiate_packet() -> Vec<u8> {
    // SMBv1协商协议请求
    vec![
        0x00, 0x00, 0x00, 0x85, 0xFF, 0x53, 0x4D, 0x42, 
        0x72, 0x00, 0x00, 0x00, 0x00, 0x18, 0x53, 0xC8, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x00, 0x02, 
        0x50, 0x43, 0x20, 0x4E, 0x45, 0x54, 0x57, 0x4F, 
        0x52, 0x4B, 0x20, 0x50, 0x52, 0x4F, 0x47, 0x52, 
        0x41, 0x4D, 0x20, 0x31, 0x2E, 0x30, 0x00, 0x02, 
        0x4C, 0x41, 0x4E, 0x4D, 0x41, 0x4E, 0x31, 0x2E, 
        0x30, 0x00, 0x02, 0x57, 0x69, 0x6E, 0x64, 0x6F, 
        0x77, 0x73, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x57, 
        0x6F, 0x72, 0x6B, 0x67, 0x72, 0x6F, 0x75, 0x70, 
        0x73, 0x20, 0x33, 0x2E, 0x31, 0x61, 0x00, 0x02, 
        0x4C, 0x4D, 0x31, 0x2E, 0x32, 0x58, 0x30, 0x30, 
        0x32, 0x00, 0x02, 0x4C, 0x41, 0x4E, 0x4D, 0x41, 
        0x4E, 0x32, 0x2E, 0x31, 0x00, 0x02, 0x4E, 0x54, 
        0x20, 0x4C, 0x4D, 0x20, 0x30, 0x2E, 0x31, 0x32, 
        0x00
    ]
}

// 检查响应是否表明系统易受SMBGhost漏洞影响
fn is_vulnerable_to_smbghost(response: &[u8]) -> bool {
    // 检查响应长度
    if response.len() < 64 {
        return false;
    }
    
    // 检查SMB2签名
    if &response[4..8] != b"\xfeSMB" {
        return false;
    }
    
    // 解析出协议版本
    // 0x0311表示SMB 3.1.1，这是易受SMBGhost影响的版本
    if response.len() >= 120 {
        for i in 100..120 {
            if i + 2 < response.len() && response[i] == 0x03 && response[i+1] == 0x11 {
                return true;
            }
        }
    }
    
    false
}

// 检查响应是否表明系统支持SMBv1
fn is_smbv1_supported(response: &[u8]) -> bool {
    // 检查响应长度
    if response.len() < 8 {
        return false;
    }
    
    // 检查SMBv1签名
    if &response[4..8] == b"\xffSMB" {
        return true;
    }
    
    false
}

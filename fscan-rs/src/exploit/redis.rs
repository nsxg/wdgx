// src/exploit/redis.rs
use std::net::IpAddr;
use std::time::Duration;
use tokio::sync::mpsc;
use tokio::time::timeout;
use tokio::io::{AsyncWriteExt, AsyncReadExt};
use log::{debug, info, error};
use crate::common::utils;
use crate::scanner::ServiceInfo;

#[derive(Debug, Clone)]
pub struct RedisVulnerability {
    pub ip: IpAddr,
    pub port: u16,
    pub vulnerability: String,
    pub details: String,
}

pub async fn scan(
    services: &[&ServiceInfo],
    timeout_secs: u64,
    threads: usize,
) -> Result<Vec<RedisVulnerability>, Box<dyn std::error::Error>> {
    if services.is_empty() {
        return Ok(Vec::new());
    }
    
    info!("Starting Redis vulnerability scanning for {} services...", services.len());
    
    let pb = utils::create_progress_bar(services.len() as u64, "Redis vulnerability scanning");
    let (tx, mut rx) = mpsc::channel(threads);
    let timeout_duration = Duration::from_secs(timeout_secs);
    
    // 分块处理
    let chunk_size = (services.len() + threads - 1) / threads;
    let chunks: Vec<Vec<&ServiceInfo>> = services
        .chunks(chunk_size)
        .map(|chunk| chunk.to_vec())
        .collect();
    
    for chunk in chunks {
        let tx = tx.clone();
        let timeout_duration = timeout_duration;
        let pb = pb.clone();
        
        tokio::spawn(async move {
            for service in &chunk {
                // 检查无认证访问漏洞
                if let Some(vuln) = check_unauth_access(service.ip, service.port, timeout_duration).await {
                    let _ = tx.send(vuln).await;
                }
                
                // 检查SSH密钥写入漏洞
                if let Some(vuln) = check_ssh_key_write(service.ip, service.port, timeout_duration).await {
                    let _ = tx.send(vuln).await;
                }
                
                // 检查Redis主从复制RCE漏洞
                if let Some(vuln) = check_master_slave_rce(service.ip, service.port, timeout_duration).await {
                    let _ = tx.send(vuln).await;
                }
                
                // 检查Redis Lua沙箱逃逸漏洞
                if let Some(vuln) = check_lua_sandbox_escape(service.ip, service.port, timeout_duration).await {
                    let _ = tx.send(vuln).await;
                }
                
                pb.inc(1);
            }
        });
    }
    
    // 丢弃原始发送者
    drop(tx);
    
    // 收集结果
    let mut results = Vec::new();
    while let Some(vuln) = rx.recv().await {
        results.push(vuln);
    }
    
    pb.finish_with_message(format!("Found {} Redis vulnerabilities", results.len()));
    
    Ok(results)
}

async fn check_unauth_access(
    ip: IpAddr,
    port: u16,
    timeout_duration: Duration,
) -> Option<RedisVulnerability> {
    let addr = format!("{}:{}", ip, port);
    
    // 尝试连接Redis
    let connect_result = timeout(
        timeout_duration, 
        async {
            match tokio::net::TcpStream::connect(&addr).await {
                Ok(mut stream) => {
                    // 发送INFO命令
                    let info_cmd = "*1\r\n$4\r\nINFO\r\n";
                    if let Err(_) = stream.write_all(info_cmd.as_bytes()).await {
                        return None;
                    }
                    
                    // 读取响应
                    let mut buffer = vec![0u8; 4096];
                    match stream.read(&mut buffer).await {
                        Ok(n) if n > 0 => {
                            let response = String::from_utf8_lossy(&buffer[..n]);
                            
                            // 检查响应是否包含Redis信息
                            if response.contains("redis_version") && !response.contains("NOAUTH") {
                                return Some(RedisVulnerability {
                                    ip,
                                    port,
                                    vulnerability: "Redis Unauthorized Access".to_string(),
                                    details: format!("Redis server at {}:{} allows unauthenticated access. Version info: {}", 
                                        ip, port, response.lines().next().unwrap_or("Unknown")),
                                });
                            }
                        },
                        _ => return None,
                    }
                    
                    None
                },
                Err(_) => None,
            }
        }
    ).await;
    
    match connect_result {
        Ok(result) => result,
        Err(_) => None,
    }
}

async fn check_ssh_key_write(
    ip: IpAddr,
    port: u16,
    timeout_duration: Duration,
) -> Option<RedisVulnerability> {
    let addr = format!("{}:{}", ip, port);
    
    // 尝试连接Redis
    let connect_result = timeout(
        timeout_duration, 
        async {
            match tokio::net::TcpStream::connect(&addr).await {
                Ok(mut stream) => {
                    // 尝试执行一系列命令以检测是否可以写入文件
                    // 注意：这里我们只检测漏洞，不实际写入SSH密钥
                    let commands = [
                        "*2\r\n$6\r\nCONFIG\r\n$3\r\nGET\r\n",
                        "*3\r\n$6\r\nCONFIG\r\n$3\r\nSET\r\n$3\r\nDIR\r\n",
                        "*1\r\n$4\r\nPING\r\n",
                    ];
                    
                    for cmd in &commands {
                        if let Err(_) = stream.write_all(cmd.as_bytes()).await {
                            return None;
                        }
                        
                        let mut buffer = vec![0u8; 1024];
                        if let Err(_) = stream.read(&mut buffer).await {
                            return None;
                        }
                    }
                    
                    // 检查CONFIG SET命令是否可用
                    let config_cmd = "*3\r\n$6\r\nCONFIG\r\n$3\r\nGET\r\n$3\r\ndir\r\n";
                    if let Err(_) = stream.write_all(config_cmd.as_bytes()).await {
                        return None;
                    }
                    
                    let mut buffer = vec![0u8; 4096];
                    match stream.read(&mut buffer).await {
                        Ok(n) if n > 0 => {
                            let response = String::from_utf8_lossy(&buffer[..n]);
                            
                            // 如果可以获取目录配置，可能存在写入文件漏洞
                            if !response.contains("NOAUTH") && response.contains("dir") {
                                return Some(RedisVulnerability {
                                    ip,
                                    port,
                                    vulnerability: "Redis SSH Key Write".to_string(),
                                    details: format!("Redis server at {}:{} allows CONFIG commands and may be vulnerable to SSH key write attacks", 
                                        ip, port),
                                });
                            }
                        },
                        _ => return None,
                    }
                    
                    None
                },
                Err(_) => None,
            }
        }
    ).await;
    
    match connect_result {
        Ok(result) => result,
        Err(_) => None,
    }
}

async fn check_master_slave_rce(
    ip: IpAddr,
    port: u16,
    timeout_duration: Duration,
) -> Option<RedisVulnerability> {
    let addr = format!("{}:{}", ip, port);
    
    // 尝试连接Redis
    let connect_result = timeout(
        timeout_duration, 
        async {
            match tokio::net::TcpStream::connect(&addr).await {
                Ok(mut stream) => {
                    // 检查是否可以执行SLAVEOF命令
                    let slave_cmd = "*3\r\n$7\r\nSLAVEOF\r\n$2\r\nNO\r\n$3\r\nONE\r\n";
                    if let Err(_) = stream.write_all(slave_cmd.as_bytes()).await {
                        return None;
                    }
                    
                    let mut buffer = vec![0u8; 1024];
                    match stream.read(&mut buffer).await {
                        Ok(n) if n > 0 => {
                            let response = String::from_utf8_lossy(&buffer[..n]);
                            
                            // 如果可以执行SLAVEOF命令，可能存在主从复制RCE漏洞
                            if !response.contains("NOAUTH") && (response.contains("OK") || response.contains("+OK")) {
                                // 检查是否支持MODULE LOAD命令（4.0+版本）
                                let info_cmd = "*1\r\n$4\r\nINFO\r\n";
                                if let Err(_) = stream.write_all(info_cmd.as_bytes()).await {
                                    return None;
                                }
                                
                                let mut buffer = vec![0u8; 4096];
                                if let Ok(n) = stream.read(&mut buffer).await {
                                    if n > 0 {
                                        let info_response = String::from_utf8_lossy(&buffer[..n]);
                                        if info_response.contains("redis_version:4.") || info_response.contains("redis_version:5.") || 
                                           info_response.contains("redis_version:6.") || info_response.contains("redis_version:7.") {
                                            return Some(RedisVulnerability {
                                                ip,
                                                port,
                                                vulnerability: "Redis Master-Slave RCE".to_string(),
                                                details: format!("Redis server at {}:{} is vulnerable to master-slave replication RCE attack (CVE-2022-0543)", 
                                                    ip, port),
                                            });
                                        }
                                    }
                                }
                            }
                        },
                        _ => return None,
                    }
                    
                    None
                },
                Err(_) => None,
            }
        }
    ).await;
    
    match connect_result {
        Ok(result) => result,
        Err(_) => None,
    }
}

async fn check_lua_sandbox_escape(
    ip: IpAddr,
    port: u16,
    timeout_duration: Duration,
) -> Option<RedisVulnerability> {
    let addr = format!("{}:{}", ip, port);
    
    // 尝试连接Redis
    let connect_result = timeout(
        timeout_duration, 
        async {
            match tokio::net::TcpStream::connect(&addr).await {
                Ok(mut stream) => {
                    // 获取Redis版本信息
                    let info_cmd = "*1\r\n$4\r\nINFO\r\n";
                    if let Err(_) = stream.write_all(info_cmd.as_bytes()).await {
                        return None;
                    }
                    
                    let mut buffer = vec![0u8; 4096];
                    match stream.read(&mut buffer).await {
                        Ok(n) if n > 0 => {
                            let info_response = String::from_utf8_lossy(&buffer[..n]);
                            
                            // 检查是否为受影响的版本（Redis 5.0.0之前）
                            if !info_response.contains("NOAUTH") {
                                // 尝试一个安全的Lua沙箱测试
                                let test_cmd = "*3\r\n$4\r\nEVAL\r\n$31\r\nreturn 'Lua sandbox test: '..1+1\r\n$1\r\n0\r\n";
                                if let Err(_) = stream.write_all(test_cmd.as_bytes()).await {
                                    return None;
                                }
                                
                                let mut buffer = vec![0u8; 1024];
                                if let Ok(n) = stream.read(&mut buffer).await {
                                    if n > 0 {
                                        let eval_response = String::from_utf8_lossy(&buffer[..n]);
                                        
                                        // 如果可以执行Lua，检查版本是否容易受到沙箱逃逸的影响
                                        if eval_response.contains("Lua sandbox test: 3") && 
                                           (info_response.contains("redis_version:3.") || 
                                            info_response.contains("redis_version:4.0.0") || 
                                            info_response.contains("redis_version:4.0.1")) {
                                            return Some(RedisVulnerability {
                                                ip,
                                                port,
                                                vulnerability: "Redis Lua Sandbox Escape".to_string(),
                                                details: format!("Redis server at {}:{} may be vulnerable to Lua sandbox escape (CVE-2022-0543)", 
                                                    ip, port),
                                            });
                                        }
                                    }
                                }
                            }
                        },
                        _ => return None,
                    }
                    
                    None
                },
                Err(_) => None,
            }
        }
    ).await;
    
    match connect_result {
        Ok(result) => result,
        Err(_) => None,
    }
}
